
The Big Picture:
----------------

Release 0.2: Refactoring, menus, full event set, graphics,
             native dialogs; more complete functionality

Release 0.3: Less API change, focus on robustness
             and stability


Objectives for version 0.2a1:
-----------------------------
(Est. early March)

* Finish the design of the new architecture.

* Implement the new architecture.

* Create a Container mixin for add() and remove(), and either a
  contents or items attribute. (With items it could be used with
  ListBox too, giving the possibility of adding and removing items...)

* Change Assignee to SmartValue, which also has support for Container
  objects.

* Change add() signature?

* Add font, alignment, and colour (?) (etc.) attributes to all
  relevant components.

New Components:

- Menus (including popup menus?)
  
- Dialogs, including native dialogs (file dialog etc.)

Objectives for version 0.2a2:
-----------------------------
(Est. late March)

* Integrate an "event path" notion into the event framework,
  facilitating the use of callbacks in containers to react to events
  from child components, possibly through a "group" class which
  functions as an event-relaying container.

* Add support for complex widgets ("megawidgets") with default
  implementations in the basic Anygui API (in the vein of the
  piddle/sping API)

  In other words, give a standardised way of integrating
  backend-specific features into Anygui programs.

* Flesh out the event list

New Components

- Canvas widget with full graphics support

- Tree widget

- Notebook/tabbed pane widget

Objectives for version 0.2a3:
-----------------------------
(Est. early April)

* Adjust defaults, and improve window staggering
  (needs a mechanism to find the top window)

* Add support for __delattr__ (in the form of _del_foobar)
  in Mixins.Attrib, and make sure it's used where applicable
  in the various modules.

* Add a grid-based layout mechanism
  (May require minimum_size and preferred_size properties)

* Add advanced support for defaults, including default
  "shrink-wrapping" of windows and frames that aren't
  given an explicit size; will require a "preferred
  size" for all widgets, based on font sizes etc.

* Implement "full" event list

New Components:

- Window status bar

- Combobox

- Progress bar

- Tables

Objectives for version 0.3:
---------------------------

* Thorough code inspection and testing to improve stability

* Implement a record/replay API for recording and simulating use of
  the GUI (on a logical level, rather than using mouse coordinates
  etc.)

  This could include using a parallel event set, with names like
  'simulate-click' (as a parallel to 'click') etc. Recording would
  then not need a separate API but could use ordinary events;
  simulation could simply send the 'simulate-foo' events which should
  be picked up and acted upon by the backend (which in turn would send
  out the appropriate 'foo' event).

* Add "applets" -- e.g. for the Gnome panel, KDE kpanel, WindowMaker
  dock, MacOS menu, Windows tray, etc. with a small window as
  fallback?

Longer term goals:
------------------

* Support accessibility standards

* Add support for styled text

* Add support for importing xml files through xslt?
  (E.g. XUL)

* Add instant model update for text widgets, not just on
  "focus lost"?

* Make Anygui more thread-safe

* Add constructive area geometry to Canvas

* Add toolbars (button bars) with menu shortcuts etc.

* Add PyKDE backend...

Smaller issues:
---------------

* Add support for borders?

* Add a linkMethods (or something) function for callback support?

* Add more distribution types (e.g. windows installers, rpms etc.)

* Add examples on how to implement other types of event systems (with
  an event path etc.) with the Anygui dispatcher to the documentation.

* Document standard way of closing a window programmatically.

* Add a fallback mechanism, making it possible to "fall back" on some
  other interface, e.g. a cmd.Cmd object. Also add a wrapper mechanism
  to ease the use of cmd.Cmd objects as event handlers (which double
  as fallbacks). A possible "callback protocol" is to require the
  fallback to be callable, and to call it if no suitable backend (save
  e.g. cursesgui and textgui) is found.

* Add idle events, to facilitate "weaving" with other periodic tasks
  without using threads.

* Add tags to the event system.
