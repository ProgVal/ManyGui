<?xml version="1.0"?>

<!DOCTYPE document SYSTEM "minimal.dtd" [
<!ENTITY shortversion            "0.1">
<!ENTITY longversion             "0.1b1">
<!ENTITY copy                    "<copyright/>">
<!ENTITY copyrightholders SYSTEM "copyrightholders.xml">
]>

<!-- TODO: - Add special tags for API reference
           - Add script for version
-->

<document version="&longversion;">

  <title>Anygui : Generic GUI for Python</title>

  <author>Magnus Lie Hetland</author>

  <date>...</date>

  <section>
    <title>Introduction</title>

    <para>The <name>Python</name> standard library currently does not
    contain any platform-independent GUI packages. It is the goal of
    the <name>Anygui</name> project to change this situation. There
    are many such packages available, but none has been defined as
    <emphasis>standard</emphasis>, so when writing GUI programs for
    <name>Python</name>, you cannot assume that your user has the
    right package installed.</para>

    <para>The problem is that declaring a GUI package as standard
    would be quite controversial. There are some packages that are
    quite commonly available, such as <name>Tkinter</name>; but it
    would not be practical to require all installations to include it,
    nor would it be desirable to require all <name>Python</name> GUI
    programs to use it, since there are many programmers who prefer
    other packages.</para>

    <para><name>Anygui</name> tries to solve this problem in a manner
    similar to the standard <code>anydbm</code> package. There is no
    need to choose <emphasis>one</emphasis> package at the expense of
    all others. Instead, <name>Anygui</name> gives generic access to
    several popular packages through a simple API, which makes it
    possible to write GUI applications that work with all these
    packages. Thus, one gets a platform-independent GUI module which
    is written entirely in <name>Python</name>.</para>

    <para>To get the latest <name>Anygui</name> distribution, or to
    get in touch with the developers, please visit the
    <name>Anygui</name> website:
    <url>http://www.anygui.org</url>.</para>

    <section>
      <title>Design Goals</title>

      <para><strong>A</strong>. <name>Anygui</name> should be an easy
      to use GUI package which may be used to create simple graphical
      programs, or which may serve as the basis for more complex
      application frameworks.</para>

      <para><strong>B</strong>. <name>Anygui</name> should be a pure
      <name>Python</name> package which serves as a front-end for as
      many as possible of the GUI packages available for
      <name>Python</name>, in a transparent manner.</para>

      <para><strong>C</strong>. <name>Anygui</name> should include
      functionality needed to perform most GUI tasks, but should
      remain as simple and basic as possible.</para>

    </section>

    <section>
      <title>Warning</title>

      <para>The <name>Anygui</name> API is currently very much in flux
      as the <name>Anygui</name> team keeps experimenting with
      it. Because of that, backwards incompatibilities may occur
      between releases. The current release should be regarded as a
      prototype.</para>

    </section>

  </section>

  <section>
    <title>Installation</title>
    
    <para>The <name>Anygui</name> package comes in the form of a
    <code>gzip</code> compressed <code>tar</code> archive. To install
    it you will first have to uncompress the archive. On
    <name>Windows</name> this can be done with <name>WinZip</name>. On
    the Mac, you can use <name>StuffIt Expander</name>. In
    <name>Unix</name>, first move to a directory where you'd like to
    put <name>Anygui</name>, and then do something like the
    following:</para>

    <codelisting>
      <line>foo:~/python$ tar xzvf anygui-&longversion;.tar.gz</line>
    </codelisting>

    <para>If your version of tar doesn't support the <code>z</code>
    switch, you can do something like this:</para>

    <codelisting>
      <line>foo:~/python$ zcat anygui-&longversion;.tar.gz | tar xvf</line>
    </codelisting>

    <para>Another possibility is:</para>

    <codelisting>
      <line>foo:~/python$ gunzip anygui-&longversion;.tar.gz</line>
    </codelisting>

    <para>No matter which version you choose, you should end up with a
    directory named <code>anygui-&longversion;</code>.</para>

    <section>
      <title>Running setup.py</title>
      
      <para>The simple way of installing <name>Anygui</name> is to use
      the installation script that's included in the
      distribution. This requires <name>Distutils</name>
      (<url>http://www.python.org/sigs/distutils-sig</url>), which is
      included in <name>Python</name> distributions from version
      2.0. To install the <name>Anygui</name> package in the default
      location, simply run the setup script with the
      <code>install</code> command:</para>

      <codelisting>
	<line>foo:~$ python setup.py install</line>
      </codelisting>

      <para>This will install <name>Anygui</name> in your standard
      <name>Python</name> directory structure. If you haven't
      installed <name>Python</name> yourself, you'll either have to
      have root access, or install it somewhere else. You can give a
      prefix with the <code>--prefix</code> option:</para>

      <codelisting>
	<line>foo:~$ python setup.py install --prefix=${HOME}/python</line>
      </codelisting>
    </section>

    <section>
      <title>Doing it Manually</title>

      <para>Since <name>Anygui</name> consists of only
      <name>Python</name> code, nothing needs to be compiled. And the
      only thing needed to install <name>Python</name> code is to
      ensure that the packages and modules are found by your
      <name>Python</name> interpreter. This may be as simple as
      including the <code>lib</code> directory of the
      <name>Anygui</name> distribution in your <code>PYTHONPATH</code>
      environment variable. In <code>bash</code>
      (<url>http://www.gnu.org/manual/bash/</url>), you could do
      something like this:</para>

      <codelisting>
	<line>foo:~$ export PYTHONPATH=$PYTHONPATH:/path/to/anygui/lib</line>
      </codelisting>

      <para>To make this permanent, you should put it in your
      <code>.bash_profile</code> file, or something equivalent. If you
      don't want to mess around with this, and already have a standard
      directory where you place your <name>Python</name> modules, you
      can simply copy (or move) the <code>lib/anygui</code>
      there, or possibly place a symlink in that directory to.</para>

    </section>

    <!--
    <section>
      <title>Distribution Layout</title>

      <para>[README, MAINTAINERS, LICENSE, etc.]</para>
    </section>
    -->

    <section>
      <title>Making Sure You Have a GUI Backend</title>

      <!-- document backend() function -->

      <para>Once you have <name>Anygui</name> installed, you'll want
      to make sure you have a usable GUI backend. This is easy to
      check: Simply start an interactive <name>Python</name>
      interpreter and try to execute the following:</para>

      <codelisting>
	<line>>>> from anygui import Application</line>
	<line>>>> Application()</line>
      </codelisting>

      <para>If this works, you should be all set for making GUI
      programs with <name>Anygui</name>. If it raises an exception,
      however, you will have to install a GUI
      package. <name>Anygui</name> currently supports the following
      packages:</para>

      <codelisting>
	<line>PythonWin  (mswgui)    <url>http://starship.python.net/crew/mhammond/win32</url></line>
	<line>Tkinter    (tkgui)     <url>http://www.python.org/topics/tkinter</url></line>
	<line>wxPython   (wxgui)     <url>http://www.wxpython.org</url></line>
	<line>Java Swing (javagui)   <url>http://www.jython.org</url></line>
	<line>PyGTK      (gtkgui)    <url>http://www.daa.com.au/~james/pygtk</url></line>
	<line>Bethon     (beosgui)   <url>http://www.bebits.com/app/1564</url></line>
	<line>Curses     (cursesgui) <url></url></line>
	<line>Plain text (textgui)   <url></url></line>
	<line>PyQt       (qtgui)     <url>http://www.thekompany.com/projects/pykde</url></line>
      </codelisting>

      <para>All of these backends are named with a short code (such as
      <code>msw</code> for <code>mswgui</code>, or PythonWin, and
      <code>wx</code> for <code>wxgui</code>, or
      <code>wxPython</code>). The code of the backend currently in use
      by a program can be retrieved with the <code>backend</code>
      function.</para>

      <para><strong>Note:</strong> The <name>BeOS</name> backen is not
      included in the current release (&longversion;), but is
      scheduled for inclusion in the final release
      (&shortversion;).</para>

      <!--
      Matt's fixes to Bethon:
      
      http://www.chariot.net.au/~jaq/matt/BWindow.dx
      http://www.chariot.net.au/~jaq/matt/BTextView.dx

      Also available at anygui.sf.net/files

      Rebuild Bethon with these.
      -->

      <para>Of these, <name>Tkinter</name> is compiled in by default
      in the <name>MS Windows</name> distribution of
      <name>Python</name> (available from
      <url>http://www.python.org</url>), <name>PythonWin</name> (as
      well as <name>Tkinter</name>) is included in the
      <name>ActiveState</name> distribution, <name>ActivePython</name>
      (available from <url>http://www.activestate.com</url>), and
      <name>Java Swing</name> is automatically available in
      <name>Jython</name>, the <name>Java</name> implementation of
      <name>Python</name>.</para>

      <para><strong>Note:</strong> <name>Anygui</name> (using
      <name>Tkinter</name>) works with <name>Mac OS</name> 9 with
      <name>Python Classic</name>. There seems to be some problems
      with <name>Python Carbon</name>.</para>

      <para>In the future <name>Anygui</name> should hopefully work in
      almost any <name>Python</name> installation, even those which do
      not have a specific GUI package installed, either by using
      Dynamic HTML together with the standard <code>webbrowser</code>
      module, or by providing some simple text interface which is
      logically equivalent to the GUI version.</para>

      <para>If you don't want to bother with all these backends, you
      may not have to. Just try to use anygui and see if it works. If
      you have a usable backend, <name>Anygui</name> will
      automatically detect it and use it.</para>

    </section>

  </section>

  <section>
    <title>Using Anygui</title>

    <para><emphasis>Note</emphasis>: For some examples of working
    <name>Anygui</name> code, see the <code>test</code> and
    <code>demo</code> directories of the distribution. Remember that
    the test scripts are written to test certain features of
    <code>Anygui</code>, not to represent recommended coding
    practices.</para>

    <para>Using <name>Anygui</name> is simple; it's simply a matter of
    importing the widgets (GUI elements) you need from the
    <code>anygui</code> module, e.g.:</para>

    <codelisting>
      <line>from anygui import *</line>
    </codelisting>

    <para>After doing this you must create an <code>Application</code>
    object, at least one <code>Window</code>, and probably a few
    components such as <code>Button</code>s and
    <code>TextField</code>s. The <code>Window</code>s are added to the
    <code>Application</code> (through its <code>add</code> method),
    and the various components are added to the
    <code>Window</code>. When you have done this, you call the
    <code>run</code> method of your <code>Application</code>
    instance.</para>

    <codelisting>
      <line># Make widgets here</line>
      <line>win = Window()</line>
      <line>app = Application()</line>
      <line>app.add(win)</line>
      <line>app.run()</line>
    </codelisting>

    <section>
      <title>Avoiding Namespace Pollution</title>
      
      <para>Importing everything from <name>Anygui</name> (as in
      <code>from anygui import *</code>) is fine for small programs,
      where you're certain that there will be no name clashes. You may
      also simply import the names you need:</para>

      <codelisting>
	<line>from anygui import Application, Window</line>
      </codelisting>

      <para>The preferred way to use modules like this is usually to
      avoid cluttering your namespace, by using simply
      <code>import anygui</code>. However, if you are going to create a lot of
      widgets, the <code>anygui</code> prefix may be
      cumbersome. Therefore, I suggest renaming it to
      <code>gui</code>, either with a simple assignment...</para>

      <codelisting>
	<line>import anygui; gui = anygui</line>
      </codelisting>

      <para>... or, in recent versions of <name>Python</name>:</para>

      <codelisting>
	<line>import anygui as gui</line>
      </codelisting>

      <para>Then you can instantiate widgets like this:</para>

      <codelisting>
	<line>win = gui.Window()</line>
      </codelisting>

      <para>Although I would recommend this practice in general, the
      examples in this documentation use the starred import, for
      simplicity.</para>

    </section>

    <section>
      <title>Importing the Backends Directly</title>

      <para>If you wish to import a backend directly (and "hardwire
      it" into your program), you may do so. For instance, if you
      wanted to use the <name>wxPython</name> backend,
      <code>wxgui</code>, you'd replace
      </para>

      <codelisting>
	<line>from anygui import *</line>
      </codelisting>

      <para>with</para>

      <codelisting>
	<line>from anygui.backends.wxgui import *</line>
      </codelisting>

      <para>This way you may use <name>Anygui</name> in standalone
      executables built with tools like <code>py2exe</code>
      (<url>http://starship.python.net/crew/theller/py2exe/</url>) or
      the McMillan installer
      (<url>http://www.mcmillan-inc.com/install1.html</url>), or with
      <code>jythonc</code> with the <code>--deep</code> option or
      equivalent.</para>

      <para>Note that the namespace handling still works just fine:</para>

      <codelisting>
	<line>import anygui.backends.tkgui as gui</line>
      </codelisting>

    </section>

    <section>
      <title>Creating a Window</title>

      <para>One of the most important classes in <name>Anygui</name>
      is <code>Window</code>. Without a <code>Window</code> you have
      no GUI; all the other widgets are added to
      <code>Window</code>s. Knowing this, we may suspect that the
      following is a minimal <name>Anygui</name> program (and we would
      be right):</para>

      <codelisting>
	<line>from anygui import *</line>
	<line>app = Application()</line>
	<line>win = Window()</line>
	<line>app.add(win)</line>
	<line>app.run()</line>
      </codelisting>
 
      <para>This example gives us a rather uninteresting default
      window. You may customise it by setting some of its properties,
      like <code>title</code> and <code>size</code>:</para>

      <codelisting>
	<line>w = Window()</line>
	<line>w.title = 'Hello, world!'</line>
	<line>w.size = (200, 100)</line>
      </codelisting>
      
      <para>If we want to, we can supply the widget properties as
      keyword arguments to the constructor:</para>

      <codelisting>
	<line>w = Window(title='Hello, world!', size=(200,100))</line>
      </codelisting>
    </section>

    <section>
      <title>The set Method and the Options Class</title>

      <para>If you want to change some attributes of a widget, you can
      either just set them directly, or (if you'd like to set several
      at once), use the <code>set</code> method, just like the
      constructor:</para>

      <codelisting>
	<line>w.set(title='Hello, again', size=(300,200))</line>
      </codelisting>

      <para>Supplying the same attributes with the same values to a
      lot of widgets (if you are making several buttons with the same
      size, for instance) can be a bit impractical (you'll learn more
      about buttons in a little while):</para>

      <codelisting>
	<line>bt1 = Button(left=10, width=50, height=30, text='Button 1')</line>
	<line>bt2 = Button(left=10, width=50, height=30, text='Button 2')</line>
	<line>bt3 = Button(left=10, width=50, height=30, text='Button 3')</line>
      </codelisting>

      <para>To deal with this, the widget constructors (and the
      <code>set</code> method) can take <code>Options</code> objects
      as positional parameters:</para>

      <codelisting>
	<line>opt = Options(left=10, width=50, height=30)</line>
	<line>bt1 = Button(opt, text='Button 1')</line>
	<line>bt2 = Button(opt, text='Button 2')</line>
	<line>bt3 = Button(opt, text='Button 3')</line>
      </codelisting>

      <para>As you can see, this saves quite a lot of typing. You can
      use as many <code>Options</code> arguments as you like.</para>
    </section>

    <section>
      <title>The modify Method</title>

      <para>Just like <code>set</code> can be used to set the
      attributes of a <code>Component</code>, the <code>modify</code>
      method can be used to <emphasis>modify</emphasis> them, without
      rebinding them to another value. To show the difference,
      consider the following example (where <code>foo</code> is an
      attribute that does nothing special):</para>

      <codelisting>
	<line>>>> from anygui import *</line>
	<line>>>> btn = Button()</line>
	<line>>>> some_list = [1, 2, 3]</line>
	<line>>>> btn.foo = some_list</line>
	<line>>>> btn.modify(foo=[4, 5, 6])</line>
	<line>>>> btn.foo</line>
	<line>[4, 5, 6]</line>
	<line>>>> some_list</line>
	<line>[4, 5, 6]</line>
	<line>>>> btn.set(foo=[7, 8, 9])</line>
	<line>>>> btn.foo</line>
	<line>[7, 8, 9]</line>
	<line>>>> some_list</line>
	<line>[4, 5, 6]</line>
      </codelisting>

      <para>As you can see, using <code>modify</code> modifies the
      list, while <code>set</code> replaces it. The
      <code>modify</code> method is very important for implementing
      Model-View-Controller systems. (More about that later.)</para>

      <para>The <code>modify</code> method works as follows: If there
      is a specific internal method for modifying an attribute, that
      is called. Otherwise, the supplied value will be assigned to
      <code>self.name[:]</code> (where <code>name</code> is the
      attribute in question). If that doesn't work (a
      <code>TypeError</code> exception is raised), the value will be
      assigned to <code>self.name.value</code>. If that doesn't work
      either, the attribute will be rebound to the new value, with the
      same result as using <code>set</code>. So, to avoid any in-place
      modification, all you need to do is use immutable values:
      </para>

      <codelisting>
	<line>>>> from anygui import *</line>
	<line>>>> btn = Button()</line>
	<line>>>> some_list = [1, 2, 3]</line>
	<line>>>> btn.foo = tuple(some_list)</line>
	<line>>>> btn.modify(foo=[4, 5, 6])</line>
	<line>>>> btn.foo</line>
	<line>[4, 5, 6]</line>
	<line>>>> some_list</line>
	<line>[1, 2, 3]</line>
      </codelisting>

    </section>

    <section>
      <title>Adding a Label</title>

      <para>Simple labels are created with the <code>Label</code>
      class:</para>

      <codelisting>
	<line>lab = Label(text='Hello, again!', position=(10,10))</line>
      </codelisting>

      <para>Here we have specified a position just for fun; we don't
      really have to. If we add the label to our window, we'll see
      that it's placed with its left topmost corner at the point
      <code>(10,10)</code>:</para>

      <codelisting>
	<line>w.add(lab)</line>
      </codelisting>

    </section>

    <section>
      <title>Layout: Placing Widgets in a Frame</title>

      <para>This section goves a simple example of positioning
      <code>Components</code>; for more information about the
      <name>Anygui</name> layout mechanism, please refer to the API
      Reference (below).</para>

      <codelisting>
	<line>win.add(lab, position=(10,10))</line>
	<line>win.add(lab, left=10, top=10)</line>
	<line>win.add(lab, top=10, right=10)</line>
	<line>win.add(lab, position=(10,10), right=10, hstretch=1)</line>
      </codelisting>

      <para>In the last example <code>hstretch</code> is a Boolean
      value indicating whether the widget should be stretched
      horizontally (to maintain the other specifications) when the
      containing <code>Frame</code> is resized. (The vertical version
      is <code>vstretch</code>.)</para>

      <section>
	<title>Placing More Than One Widget</title>

	<para>The <code>add</code> method can also position a
	<emphasis>sequence</emphasis> of widgets. The first widget
	will be placed as before, while the subsequent ones will be
	placed either to the <code>right</code>, to the
	<code>left</code>, above (<code>up</code>), or below
	(<code>down</code>), according to the <code>direction</code>
	argument, at a given distance (<code>space</code>):</para>

	<codelisting>
	  <line>win.add((lab1, lab2), position=(10,10),</line>
	  <line>        direction='right', space=10)</line>
	</codelisting>

	<para><strong>Note:</strong> Remember to enclose your
	components in a sequence (such as a tuple or a list), since
	<code>add</code> allows you to use more positional arguments,
	but will treat them differently. For more information see the
	section about the <code>Frame</code> class in the API
	Reference below.</para>

      </section>

    </section>

    <section>
      <title>Buttons and Event Handling</title>

      <para><code>Buttons</code> (as most <code>Components</code>)
      work more or less the same way as <code>Labels</code>. You can
      set their <code>size</code>, their <code>position</code>, their
      <code>text</code>, etc. and then <code>add</code> them to a
      <code>Frame</code> (such as a <code>Window</code>). The thing
      that makes them interesting is that they emit
      <emphasis>events</emphasis>. Each time the user clicks a button,
      it sends out a <code>click</code> event. You can catch these
      events by linking your button to one or more <emphasis>event
      handlers</emphasis>. It's really simple:</para>

      <codelisting>
	<line>btn = Button(text='Greet Environment')</line>
	<line>def greeting(**args):</line>
	<line>    print 'Hello, World!'</line>
	<line>link(btn, greeting)</line>
      </codelisting>

      <para>The event handling is taken care of by the call to
      <code>link</code>. An event handler may receive several keyword
      arguments, and if you're not particularly interested in any of
      them, simply use something like <code>**args</code> above. (For
      more information about this, see the section about global
      functions in the API Reference below.)</para>

    </section>

    <section>
      <title>About Models, Views, and Controllers</title>

      <para>The <name>Anygui</name> MVC mechanism (based on the
      <code>update</code> method and the <code>Assignee</code>
      protocol) is described in the API Reference below. Here is a
      short overview on how to use it.</para>

      <para>A <emphasis>model</emphasis> is an object that can be
      modified, and that can notify other objects, called
      <code>views</code>, when it has been modified. A
      <code>controller</code> is an object that can modify the model,
      in particular as a direct response to a user action (such as
      clicking the mouse or typing some text). In <name>Anygui</name>,
      <code>Component</code>s double as both views (showing a model's
      state to the user) and controllers (letting the user modify the
      model). Even though <name>Anygui</name> supports using models
      this way, you can also create complete application without using
      them.</para>
      
      <para>Models are in general subclasses of the <code>Model</code>
      class (although they don't have to be; see the API Reference
      below for a description of how they work). The
      <code>Model</code>s that are included in <name>Anygui</name>
      are:</para>

      <codelisting>
	<line>BooleanModel     -- represents a Boolean value</line>
	<line>ListModel        -- behaves like a list</line>
	<line>NumberModel      -- represents a numerical value</line>
	<line>TextModel        -- acts like a mutable string</line>
      </codelisting>

      <para>These all have a <code>value</code> attribute which may be
      used to change their internal value. They also support other
      operations, such as indexing and slicing etc. for
      <code>ListModel</code>. These are very easy to use: Just assign
      them to an attribute of a <code>Component</code>:</para>

      <codelisting>
	<line># You'll learn about CheckBoxes in a minute</line>
	<line>cbx = CheckBox(text='Simple model test')</line>
	<line>state = BooleanModel(value=1)</line>
	<line>cbx.on = state</line>
      </codelisting>

      <para>Now, if you change <code>state</code> (e.g. with the
      statement <code>state.value=0</code>) this will automatically be
      reflected in the <code>CheckBox</code> (which will be acting
      like a view). If the user clicks the <code>CheckBox</code>, the
      model will be changed.</para>

      <para>You can always update views yourself, by calling their
      <code>update</code> method. This can be useful also if you use a
      simple value such as a list in an attribute:</para>

      <codelisting>
	<line>btn = Button()</line>
	<line>rect = [0, 0, 10, 10]</line>
	<line>btn.geometry = rect</line>
	<line>rect[3] = 20</line>
	<line>btn.update()</line>
      </codelisting>

      <para>After modifying <code>rect</code>, the button will not
      have changed, since it can't detect the change by
      itself. (That's only possible when you use a real model.)
      Therefore, you call <code>btn.update</code> to tell it to update
      itself.</para>

      <para>If you assign a value to an attribute, the
      <code>update</code> method will be called automatically, so
      another way of doing the same thing is:</para>

      <codelisting>
	<line>btn = Button()</line>
	<line>rect = [0, 0, 10, 10]</line>
	<line>btn.geometry = rect</line>
	<line>rect[3] = 20</line>
	<line>btn.geometry = rect</line>
      </codelisting>

      <para><strong>Warning:</strong> Because of the controller behaviour
      of <code>Component</code>s, if the <code>Button</code> is
      resized, <code>rect</code> will be modified. If you don't want
      this behaviour, use a tuple instead of a list, since tuples
      can't be modified.</para>

      <para>If you want another object to monitor a model, you can
      simply use the <code>link</code> method, since all models
      generate an event (of the type <code>default</code>) when they
      are modified.</para>

    </section>

    <section>
      <title>Using CheckBoxes</title>

      <para>A <code>CheckBox</code> is a <emphasis>toggle
      button</emphasis>, a button which can be in one of two states,
      "on" or "off". Except for that, it works more or less like any
      other button in that you can place it, set its text, and
      link an event handler to it.</para>

      <para>Whether a <code>CheckBox</code> is currently on or off is
      indicated by its <code>on</code> attribute.</para>

    </section>

    <section>
      <title>RadioButtons and RadioGroups</title>

      <para><code>RadioButton</code>s are toggle buttons, just like
      <code>CheckBox</code>es. The main differences are that they look
      slightly different, and that they should belong to a
      <code>RadioGroup</code>.</para>

      <para>A <code>RadioGroup</code> is a set of
      <code>RadioButton</code>s where only <emphasis>one</emphasis>
      <code>RadioButton</code> is permitted to be "on" at one
      time. Thus, when one of the buttons in the group is turned on,
      the others are automatically turned off. This can be useful for
      selecting among different alternatives.</para>

      <para><code>RadioButton</code>s are added to a
      <code>RadioGroup</code> by setting their <code>group</code>
      property:</para>

      <codelisting>
	<line>radiobutton.group = radiogroup</line>
      </codelisting>

      <para>This may also be done when constructing the button:</para>

      <codelisting>
	<line>grp = RadioGroup()</line>
	<line>rbn = RadioButton(group=grp)</line>
      </codelisting>

      <!-- Document RadioGroup add method...? -->

    </section>

    <section>
      <title>ListBox</title>

      <para>A <code>ListBox</code> is a vertical list of items that
      can be selected, either by clicking on them, or by moving the
      selection up and down with the arrow keys. (For the arrow keys
      to work, you must make sure that the <code>ListBox</code> has
      keyboard focus. In some backends this requires using the
      <code>tab</code> key.)</para>

      <para><emphasis>Note</emphasis>: When using <name>Anygui</name>
      with <name>Tkinter</name>, using the arrow keys won't change the
      selection, only which item is underlined. You'll have to use the
      arrow keys until the item you want to select is underlined; then
      select it by pressing the space bar.</para>

      <para>A <code>ListBox</code>'s items are stored in its attribute
      <code>items</code>, a sequence of arbitrary objects. The
      text displayed in the widget will be the result of applying the
      built-in <name>Python</name> function <code>str</code> to each
      object.</para>

      <codelisting>
	<line>lbx = ListBox()</line>
	<line>lbx.items = 'This is a test'.split()</line>
      </codelisting>

      <para>The currently selected item can be queried or set through
      the <code>selection</code> property (an integer index, counting
      from zero). Also, when an item is selected, a
      <code>select</code> event is generated, which is the default
      event type for a <code>ListBox</code>. This means that you can
      either do</para>

      <codelisting>
	<line>link(lbx, 'select', handler)</line>
      </codelisting>

      <para>or</para>

      <codelisting>
	<line>link(lbx, handler)</line>
      </codelisting>

      <para>with the same result. (This is similar to the
      <code>click</code> event, which is default for
      <code>Buttons</code>; for more information, see the API
      Reference below.)</para>

    </section>

    <section>
      <title>TextField and TextArea</title>

      <para><name>Anygui</name>'s two text widgets,
      <code>TextField</code> and <code>TextArea</code> are quite
      similar. The difference between them is that
      <code>TextField</code> permits neither newlines or tab
      characters to be typed, while <code>TextArea</code> does. Typing
      a tab in a <code>TextField</code> will simply move the focus to
      another widget, while pressing the enter key will send an
      <code>enterkey</code> event (which is the
      <code>TextField</code>'s default event type).</para>

      <para>The text in a text component is stored in its
      <code>text</code> property (a string or equivalent), and the
      current selection is stored in its <code>selection</code>
      property (a tuple of two integer indices).</para>
    </section>

  </section>

  <section>
    <title>API Reference</title>

    <para>The following reference describes the full official API of
    the current version (&longversion;) of <name>Anygui</name>.</para>
    
    <section>
      <title>Environment Variables</title>
      
      <para>Some environment variables affect the behaviour of the
      <name>Anygui</name> package. These must be set in the
      environment of the program using <name>Anygui</name>. They may
      either be set permanently through normal operating system
      channels (check your OS documentation for this), or possibly
      just set temporarily when running your program. In
      <name>Unix</name> shells like <name>bash</name>, you can set the
      variables on the command line before your comand, like this:</para>

      <codelisting>
	<line>foo:~$ ANYGUI_SOMEVAR='some value' python someprogram.py</line>
      </codelisting>

      <para>where <code>ANYGUI_SOMEVAR</code> is some environment
      variable used by <name>Anygui</name>.</para>

      <para>Since <name>Jython</name> doesn't support OS environment
      variables, you'll have to supply them with the command-line
      switch <code>-D</code>: </para>

      <codelisting>
	<line>foo:~$ jython -DANYGUI_SOMEVAR='some value' someprogram.py</line>
      </codelisting>

      <para>You can also set these environment variables in your own
      program, by using code like the following before you import
      <name>Anygui</name>:</para>

      <codelisting>
	<line>import os</line>
	<line>os.environ['ANYGUI_SOMEVAR'] = 'some value'</line>
      </codelisting>

      <para>This will probably not work in <name>Jython</name>, though.</para>
      
      <para>The environment variables used by <name>Anygui</name>
      are:</para>

      <para><code>ANYGUI_WISHLIST</code>: A whitespace separated list
      of backend names in the order you wish for <name>Anygui</name>
      to try to use them. The backends are identified with a short
      prefix such as <code>wx</code> for <code>wxgui</code>, or
      <code>tk</code> for <code>tkgui</code>. For a full list of
      available backends, see the section "Making Sure You Have a GUI
      Backend" above. If none of the backends you supplied work,
      <name>Anygui</name> will continue searching through the other
      backends for a viable alternative.</para>

      <!--
      Document default order.
      Documentation synch problem?
      Document the star symbol and the new semantics.
      -->

      <para>Example:</para>

      <codelisting>
	<line>foo:~$ ANYGUI_WISHLIST='tk wx qt' python someprogram.py</line>
      </codelisting>
      
      <para><code>ANYGUI_DEBUG</code>: When <name>Anygui</name> tries
      to import a backend, it hides all exceptions, assuming they are
      caused by the fact that a given backend doesn't work in your
      installation (because you don't have it installed or something
      similar). However, at times this may not be the reason; it may
      simple be that a given backend contains a bug. To track down the
      bug, set the <code>ANYGUI_WISHLIST</code> to some true (in a
      <name>Python</name> sense) value. (If the value supplied can be
      converted to an integer, it will. Otherwise, it will be treated
      as a string.) This will make <name>Anygui</name> print out the
      stack traces from each backend it tries to import.</para>

      <!--
      Document new star semantics
      -->

      <para>Example:</para>

      <codelisting>
	<line>foo:~$ ANYGUI_DEBUG=1 python someprogram.py</line>
      </codelisting>

      <para><code>ANYGUI_ALTERNATE_BORDER</code>: </para>

      <para><code>ANYGUI_SCREENSIZE</code>: </para>

      <!--
      From Joe:

      You can now set ANYGUI_ALTERNATE_BORDER=1 in the environment
      to get +-| borders on strange terminal emulators. This is
      mentioned on the initial help screen as well.

      ANYGUI_SCREENSIZE
      ANYGUI_SKIP # Test script...
      ANYGUI_CURSES_NOHELP=1
      -->
	
    </section>

    <section>
      <title>Global Functions</title>

      <para><apiname>application</apiname>()</para>

      <para>Returns the current <code>Application</code>
      object.</para>

      <para><apiname>backend</apiname>()</para>

      <para>Returns the name (as used in <code>ANYGUI_WISHLIST</code>)
      of the backend currently in use.</para>

      <para>Example:</para>

      <codelisting>
	<line>if backend() == 'wx':</line>
	<line>    some_wx_code()</line>
	<line>else:</line>
	<line>    some_generic_code()</line>
      </codelisting>

      <para><apiname>link</apiname>(<var>source</var>,
      [<var>event</var>,] <var>handler</var>, <var>weak</var>=0,
      <var>loop</var>=0)</para>

      <para>Creates a link in the <name>Anygui</name> event system,
      between the <code>source</code> (any object) and the
      <code>handler</code> (any callable, or a <code>(obj,func)</code>
      pair, where <code>func</code> is an unbound method or function,
      and <code>obj</code> is an object which will be supplied as the
      first parameter to <code>func</code>). Supplying an
      <code>event</code> (a string) will make the link carry only
      information about events of that type. If no event is supplied,
      <code>'default'</code> will be assumed. Setting
      <code>weak</code> to a true value will use weak references when
      setting up the link, so that no objects will be "kept alive" by
      the event system. A send-loop occurs if an object sends an event
      "to itself" (i.e. it is the source of a call to
      <code>link</code> which hasn't returned at the point where one
      of its methods are about to be activated as a handler). The
      truth value <code>loop</code> decides whether this handler will
      be activated in such a loop. (If <code>send</code> was called
      with <code>loop=1</code>, loops will be allowed anyway.)
      </para>

      <para>Note that <code>source</code>, <code>event</code>, and
      <code>handler</code> are strictly positional parameters, while
      the others (<code>weak</code>, and <code>loop</code>) must be
      supplied as keyword parameters.</para>

      <para>For more information on sending events, see
      <code>send</code>, below.</para>

      <para><apiname>send</apiname>(<var>source</var>,
      <var>event</var>=<code>'default'</code>, <var>loop</var>=0,
      **<var>kwds</var>)</para>

      <!-- Add stuff about order, especially any-sources etc. -->

      <para>When this is called, any handlers (callables) linked to
      the source, but which will not cause a send-loop (unless
      <code>loop</code> is true) will be called with all the keyword
      arguments provided, in the order in which they were linked. In
      addition to the supplied keyword arguments, the event framework
      will add <code>source</code>, <code>event</code>, and the time
      (as measured by the standard <name>Python</name> function
      <code>time.time</code>) when <code>send</code> was called.
      </para>

      <para>Note that <code>source</code>, and <code>event</code>, are
      strictly positional parameters, while the others
      (<code>loop</code>, and any additional arguments the user might
      add) must be supplied as keyword parameters.</para>

      <para>Example:</para>

      <codelisting>
	<line># Link an event handler to a button, and then manually send a</line>
	<line># default event from the button. This event would have been</line>
	<line># sent automatically if we clicked the button. Note that we</line>
	<line># only use the arguments we need, and lump the rest in **kw.</line>
	<line></line>
	<line>def click(source, time, **kw):</line>
	<line>    print 'Button %s clicked at %f.' % (source.text, time)</line>
	<line></line>
	<line>btn = Button(text='Click me')</line>
	<line>link(btn, click)</line>
	<line></line>
	<line>send(btn) # Fake a button click -- will call click()</line>
      </codelisting>

      <para><apiname>unlink</apiname>(<var>source</var>,
      [<var>event</var>,] <var>handler</var>)</para>

      <para>Undoes a call to <code>link</code> with the same
      positional arguments.  <!-- TODO: Describe use of the "any"
      value -->
      </para>

      <para><apiname>unlinkHandler</apiname>(<var>handler</var>)</para>

      <para>Removes a handler completely from the event
      framework.</para>

      <para><apiname>unlinkMethods</apiname>(<var>obj</var>)</para>

      <para>Unlinks all handlers that are methods of
      <code>obj</code>.</para>

      <para><apiname>unlinkSource</apiname>(<var>source</var>)</para>

      <para>Remove the source (and all handlers linked to it) from the
      event framework.</para>

    </section>

    <section>
      <title>Classes</title>
       
      <para><strong>Base Classes and Common Behaviour</strong></para>

      <!-- document set and modify -->

      <!-- Add info about update() and the assignee protocol, if
      adopted; models... -->

      <para>All components are subclasses of corresponding abstract
      components which implement behaviour common to all the
      backends. So, for instance, <code>Button</code> subclasses
      <code>AbstractButton</code>. These abstract components, again,
      subclass <code>AbstractComponent</code>, which implements
      behaviour common to all componnets.</para>

      <para>Perhaps the most important behaviour is attribute handling
      (inherited from the <code>Attrib</code> mixin), which means that
      setting a components attributes may trigger some internal method
      calls. For instance,</para>

      <codelisting>
	<line>win.size = 300, 200</line>
      </codelisting>

      <para>will automatically resize the component
      <code>win</code>. Attributes common to all components are:</para>

      <codelisting>
	<line>x         -- x-coordinate of upper left corner</line>
	<line>y         -- y-coordinate of upper left corner</line>
	<line>position  -- equivalent to (x, y)</line>
	<line>width     -- component width</line>
	<line>height    -- component height</line>
	<line>size      -- equivalent to (width, height)</line>
	<line>geometry  -- equivalent to (x, y, width, height)</line>
	<line>visible   -- whether the component is visible</line>
	<line>enabled   -- whether the component is enabled</line>
	<line>text      -- text associated with the component</line>
      </codelisting>

      <para>Common to <code>Application</code>, <code>Window</code>,
      and <code>Frame</code> is the <code>contents</code> attribute,
      as well as the <code>add</code> and <code>remove</code>
      methods. These will be described with the individual classes
      below.</para>

      <para><strong>Assignee and update()</strong></para>
      
      <para>When an attribute of a <code>Component</code> (or
      <code>Application</code>, <code>RadioGroup</code>, or an
      instance of another <code>Attrib</code> subclass) is assigned a
      value, the <code>Component</code> is automatically updated to
      reflect its new state. For instance, if you have a
      <code>Label</code> <code>lbl</code>, assigning a value to
      <code>lbl.geometry</code> would immediately change the
      <code>Label</code>'s geometry, and assigning to
      <code>lbl.text</code> would change its text.</para>

      <para>This is good enough for most cases, but sometimes an
      attribute can contain a mutable value, such as a list, and
      changing that will not update the <code>Component</code>. For
      instance, if you use a list to hold the <code>items</code> of a
      <code>ListBox</code>, you could end up in the following
      situation:</para>

      <codelisting>
	<line>lbx = ListBox()</line>
	<line>lbx.items = 'first second third'.split()</line>
	<line># More code...</line>
	<line>lbx.items.append('fourth')</line>
      </codelisting>

      <para>After performing this code, nothing will have happened to
      the <code>ListBox</code>, because it has no way of knowing that
      the list has changed. To fix that, you can simply call its
      <code>update</code> method:</para>

      <codelisting>
	<line>lbx.update()</line>
      </codelisting>

      <para>This method checks whether any attributes have changed,
      and make sure that the <code>Component</code> us up to
      date.</para>

      <para><strong>Updating Automatically</strong></para>

      <para>Updating <code>Components</code> explicitly can be useful,
      but sometimes you would want it to be done for you,
      automatically, each time you modify an object that is referred
      to by a <code>Component</code> attribute. This can be taken care
      of by <code>link</code> and <code>send</code>. If your object
      uses <code>send</code> every time it's modified, and you
      <code>link</code> the object to your <code>Component</code>'s
      <code>update</code> method, things will happen by
      themselves:</para>

      <codelisting>
	<line>class TriggerList:</line>
	<line>    def __init__(self):</line>
	<line>        self.list = []</line>
	<line>    def append(self, obj):</line>
	<line>        self.list.append(obj)</line>
	<line>        send(self)</line>
	<line>    def __getitem__(self, i):</line>
	<line>        return self.list[i]</line>
	<line></line>
	<line>lbx = ListBox()</line>
	<line>lbx.items = TriggerList()</line>
	<line>link(lbx.items, lbx.update)</line>
      </codelisting>

      <para>Now, if we call <code>lbx.items.append('fourth')</code>,
      <code>lbx.update</code> will automatically be called. To make
      your life easier, <name>Anygui</name> already contains some
      classes that send signals whend they are modified; these classes
      are called <code>Model</code>s.</para>

      <para><strong>Model and Assignee</strong></para>

      <para>The <name>Anygui</name> models (<code>BooleanModel</code>,
      <code>ListModel</code>, <code>TextModel</code>, and
      <code>NumberModel</code>) are objects that call
      <code>send</code> (with the <code>'default'</code> event) when
      they are modified.</para>

      <para>An <code>Assignee</code> (part of the <name>Anygui</name>
      Model-View-Controller mechanism) is an object that supports the
      methods <code>assigned</code> and <code>removed</code>. These
      are automatically called (if present) when the object is
      assigned to one of the attributes of an <code>Attrib</code>
      object (such as a <code>Component</code>). <code>Model</code>s
      use this behaviour to automatically call <code>link</code> and
      <code>unlink</code>, so when the <code>Model</code> is modified,
      the <code>update</code> method of the <code>Attrib</code> object
      is called automatically.</para>

      <!-- document the value attribute -->

      <para><strong>class Application</strong></para>

      <para>To instantiate <code>Window</code>s, you must have an
      <code>Application</code> to manage them. You typically
      instantiate an application at the beginning of your
      program:</para>

      <codelisting>
	<line>app = Application()</line>
	<line># Build GUI and run application</line>
      </codelisting>

      <para>In some cases subclassing <code>Application</code> might
      be a useful way of structuring your program, but it is in no way
      required.</para>

      <para><code>Application</code> has the following methods:</para>

      <para><apiname>run</apiname>()</para>

      <para>Starts the main event loop of the graphical user
      interface. Usually called at the end of the program which set up
      the interface:</para>

      <codelisting>
	<line>app = Application()</line>
	<line># Set up interface</line>
	<line>app.run()</line>
      </codelisting>
    
      <para><apiname>add</apiname>(<var>win</var>)</para>

      <para>Adds a <code>Window</code> to the
      <code>Application</code>, in the same way
      <code>Components</code> can be added to <code>Frame</code>s (see
      below). A <code>Window</code> will not be visible until it has
      been <code>add</code>ed to the current <code>Application</code>
      object, and that <code>Application is running</code>. When
      constructing new <code>Window</code>s after
      <code>Application.run</code> has been called, you should ensure
      that you <code>add</code> your <code>Window</code> to your
      running <code>Application</code> <emphasis>after</emphasis> all
      the <code>Components</code> have been added to your
      <code>Window</code>; otherwise, you may see them appearing and
      moving about as <name>Anygui</name> takes care of the
      layout. (Before <code>Application.run</code> is called, this is
      not an issue, since no <code>Window</code>s will be appear
      before that time.)</para>
 
      <para>The parameter <code>win</code> can be either a single
      <code>Window</code>, or a sequence of
      <code>Windows</code>.</para>

      <para><apiname>remove</apiname>(<var>win</var>)</para>

      <para>Removes a <code>Window</code> from the application. This
      will make the <code>Window</code> disappear.</para>

      <para><apiname>contents</apiname></para>

      <para>A read-only property containing a tuple of the
      <code>Window</code>s the <code>Application</code> currently
      manages.</para>

      <para><strong>class Button</strong></para>

      <para>A component which, when pressed, generate a
      <code>'click'</code> event, as well as a <code>'default'</code>
      event. Thus, in the following example, both
      <code>handler1</code> and <code>handler2</code> will be called
      when the button is pressed:</para>

      <codelisting>
	<line>btn = Button()</line>
	<line>def handler1(**kw): print 'Handler 1'</line>
	<line>def handler2(**kw): print 'Handler 2'</line>
	<line>link(btn, 'click', handler1)</line>
	<line>link(btn, handler2)</line>
      </codelisting>
    
      <para><strong>class CheckBox</strong></para>

      <para><code>CheckBox</code> is a kind of button, and thus will
      also generate <code>'click'</code> and <code>'default'</code>
      events when clicked. But in addition, each <code>CheckBox</code>
      has a Boolean attribute <code>on</code>, which is toggled each
      time the box is clicked. The state of the <code>CheckBox</code>
      can be altered by assigning to this attribute.</para>
    
      <para>The <code>on</code> attribute is a useful place to use a
      <code>BooleanModel</code>.</para>

      <para><strong>class Frame</strong></para>
  
      <para><code>Frame</code> is a component which can contain other
      components. Components are added to the <code>Frame</code> with
      the <code>add</code> method:</para>

      <para><apiname>add</apiname>(<var>comp</var>, [<var>opts</var>,] **<var>kwds</var>)</para>
      
      <para>Adds one or more components. The parameter
      <code>comp</code> may be either a single component, or a
      sequence of components. In the latter case, all the components
      will be added.</para>

      <para>The <code>opts</code> parameter containes an
      <code>Options</code> object (see below) which gives information
      about how the object should be laid out. These options can be
      overridden with keyword arguments, and all this information will
      be passed to the <code>LayougManager</code> (see below) of the
      <code>Frame</code>, if any. This <code>LayougManager</code> is
      stored in the <code>layout</code> property.</para>

      <para><apiname>remove</apiname>(<var>comp</var>)</para>

      <para>Removes a component from the <code>Frame</code>.</para>

      <para><apiname>contents</apiname></para>

      <para>This is a read-only property which contains the contents
      (a tuple of <code>Components</code>) of the
      <code>Frame</code>.</para>

      <!-- This property should perhaps behave like other properties? -->

      <para><strong>class Label</strong></para>

      <para>A <code>Label</code> is a simple component which displays
      a string of text. (<code>Label</code> can only handle one line
      of text.)</para>
      
      <para><strong>class LayoutManager</strong></para>

      <para>A layout manager is responsible for setting the
      <code>geometry</code> properties of a set of components when
      their parent <code>Frame</code> changes shape. <!-- A layout
      manager should subclass <code>LayoutManager</code>, and then
      implement the following methods: --> The default
      <code>LayoutManager</code> (and the only one supplied with the
      current release) is the <code>Placer</code> (see below).
      </para>

      <para><strong>Note:</strong> Although Anygui &shortversion;
      comes only with this layout manager, more will appear in the
      future.</para>

      <para><strong>class ListBox</strong></para>
      
      <para>Shows a list of options, of which one may be selected. The
      <code>ListBox</code> has two special attributes:
      <code>items</code>, a sequence of items to display, and
      <code>selection</code>, the currently selected (as an index in
      the <code>items</code> sequence).</para>

      <para>The <code>selection</code> property will be automatically
      modified (as per the MVC mechanism) when the user makes a
      selection. This will also cause the <code>ListBox</code> to
      <code>send</code> a <code>select</code> event.</para>

      <para><strong>class Model</strong></para>

      <para>See the section on <code>Model</code> and
      <code>Assignee</code> above.</para>

      <para><strong>class Options</strong></para>
      
      <para><code>Options</code> is a very simple class. It is simply
      used to store a bunch of named values; basically a dictionary
      with a different syntax. (For more information about the
      <name>bunch</name> class, see
      <url>http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/52308</url>.)</para>
           
      <para>You can set the attributes of an <code>Options</code>
      object and then supply it as an optional first parameter to the
      constructors of widgets:</para>

      <codelisting>
	<line>opt = Options()</line>
	<line>opt.width = 100</line>
	<line>opt.height = 50</line>
	<line>opt.x = 10</line>
	<line>btn = Button(opt, y=10)</line>
	<line>lbl = Label(opt, y=70)</line>
      </codelisting>

      <para>Here <code>btn</code> and <code>lbl</code> will have the
      same <code>width</code>, <code>height</code>, and <code>x</code>
      attributes, but differing <code>y</code> attributes.</para>

      <para>You can also set the attributes of an <code>Options</code>
      object through its constructur, just like with
      components:</para>

      <codelisting>
	<line>opt = Options(width=100, height=50, x=10)</line>
      </codelisting>
      
      <para><code>Options</code> objects can also be used when
      supplying arguments to the <code>add</code> method of
      <code>Frame</code>:</para>

      <codelisting>
	<line># Assuming a Placer LayoutManager:</line>
	<line>opt = Options(left=10, right=10, hstretch=1)</line>
	<line>win.add(lbl, opt, top=10)</line>
	<line>win.add(btn, opt, top=(lbl,10))</line>
      </codelisting>

      <para><strong>class Placer</strong></para>

      <para>A simple but powerful layout manager. When adding
      components to a <code>Frame</code> whose <code>layout</code>
      attribute is set to a <code>Placer</code>, you can supply the
      following keyword arguments:</para>

      <codelisting>
	<line>left         -- the Component's left edge</line>
	<line>right        -- the Component's right edge</line>
	<line>top          -- the Component's top edge</line>
	<line>bottom       -- the Component's bottom edge</line>
	<line>hmove        -- move horizontally on resize</line>
	<line>vmove        -- move vertically on resize</line>
	<line>hstretch     -- stretch horizontally on resize</line>
	<line>vstretch     -- stretch vertically on resize</line>
	<line>direction    -- 'left', 'right', 'up', or 'down'</line>
	<line>space        -- spacing between multiple Components</line>
      </codelisting>

      <para>The geometry specifiers (<code>left</code>,
      <code>right</code>, <code>top</code>, and <code>bottom</code>)
      can be set to either <code>None</code> (the default; will use
      the <code>Component</code>'s existing coordinates), a distance
      (from the corresponding <code>Frame</code> edge), a
      <code>Component</code> (will align the edge with the opposite
      edge of the given component), or a tuple
      (<emphasis>component</emphasis>, <emphasis>distance</emphasis>)
      (as with only a <code>Component</code>, except that a gap of
      size <emphasis>distance</emphasis> is inserted between the
      two).</para>

      <para>The movement arguments (<code>hmove</code> and
      <code>vmove</code>) specify (with a Boolean value) whether the
      <code>Component</code> should be moved (horizontally,
      vertically, or both) to maintain the given distance to the
      surrounding <code>Frame</code>'s edges; the stretching arguments
      (<code>hstretch</code> and <code>vstretch</code>) specify
      whether the <code>Component</code> may be stretched to maintain
      these distances.</para>

      <para><strong>class RadioButton</strong></para>
      
      <para>A <code>RadioButton</code> is a toggle button, just like
      <code>CheckBox</code>, with slightly different appearance, and
      with the difference that it belongs to a
      <code>RadioGroup</code>. Only one <code>RadioButton</code> can
      be active (have its <code>on</code> attribute be a true Boolean
      value)in the <code>RadioGroup</code> at one time, so when one is
      clicked or programmatically turned on, the others are
      automatically switched off by the <code>RadioGroup</code>. Each
      <code>RadioButton</code> also has a <code>value</code>
      attribute, which should be unique within its
      <code>RadioGroup</code>. When one <code>RadioButton</code> is
      active, the <code>value</code> attribute of its
      <code>RadioGroup</code> is automatically set to that of the
      active <code>RadioButton</code>. The <code>RadioGroup</code> of
      a <code>RadioButton</code> is set by assigning the
      <code>RadioGroup</code> to the <code>group</code> attribute of
      the <code>RadioButton</code>. Setting the <code>value</code>
      attribute of the <code>RadioGroup</code> will automatically
      activate the correct <code>RadioButton</code>.</para>
      
      <para><strong>class RadioGroup</strong></para>
      
      <para>See <code>RadioButton</code> above.</para>
          
      <para><strong>class TextArea</strong></para>

      <para>A multiline text-editing <code>Component</code>. Its text
      is stored in the <code>text</code> attribute, which will be
      modified (according to the MVC mechanism) when the component
      loses focus. It also supports the Boolean <code>editable</code>
      property, which may be used to control whether the user can edit
      the text area or not.</para>
    
      <para><strong>class TextField</strong></para>

      <para>A one-line text-editing <code>Component</code>. (See also
      <code>TextArea</code>, above.) If the enter/return key is
      pressed within a <code>TextField</code>, the
      <code>TextField</code> will <code>send</code> a
      <code>enterkey</code> event.</para>
        
      <para><strong>class Window</strong></para>

      <para>A window, plain and simple. <code>Window</code> is a type
      of <code>Frame</code>, so you can add components to it and set
      its <code>layout</code> property etc. To make your window
      appear, you must remember to add it to your
      <code>Application</code>, just like you add other components to
      <code>Frame</code>s and <code>Window</code>s:</para>

      <codelisting>
	<line>win = Window()</line>
	<line>app = Application()</line>
	<line>app.add(win)</line>
	<line>app.run()</line>
      </codelisting>

      <para><code>Window</code>s have a <code>title</code> attribute
      which may be used by the operating system or window
      manager to identify the window to the user in various ways.</para>

    </section>

  </section>

  <section>
    <title>Known Problems</title>
    
    <para>For an overview of known bugs in the current release, see
    the file <code>KNOWN_BUGS</code> found in the distribution.</para>

  </section>

  <section>
    <title>Plans for Future Releases</title>

    <para>For an overview of future plans, see the <code>TODO</code>
    file found in the distribution. <!-- Some plans are also described in
    the IRFCs (<url>http://anygui.sf.net/irfc</url>). --></para>

  </section>

  <section>
    <title>Contributing</title>

    <para>If you want to contribute to the <name>Anygui</name>
    project, we could certainly use your help. First of all, you
    should visit the <name>Anygui</name> web site at
    <url>http://www.anygui.org</url>, subscribe to the developer's mailing
    list (<code>devel@anygui.org</code>) and the user's list
    (<code>users@anygui.org</code>), and try to familiarise yourself
    with how the package works behind the scenes. Then, you may either
    help develop the currently supported GUI packages, or you may
    start writing a backend of your own. Several potential backend
    targets may be found at
    <url>http://starbase.neosoft.com/~claird/comp.lang.python/python_GUI.html</url>.
    </para>

  </section>

  <section>
    <title>Anygui License</title>

    <para>Copyright &copy; 2001 &copyrightholders;.</para>

    <para>Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation
    files (the "Software"), to deal in the Software without
    restriction, including without limitation the rights to use, copy,
    modify, merge, publish, distribute, sublicense, and/or sell copies
    of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:</para>

    <para>The above copyright notice and this permission notice shall
    be included in all copies or substantial portions of the
    Software.</para>

    <para>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY
    KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
    WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE
    AND NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.</para>
  </section>

</document>
